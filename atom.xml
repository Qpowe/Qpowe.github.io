<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Qpowe&#39;s Dirty life</title>
  
  <subtitle>Qpowe&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://qpowe.github.io/"/>
  <updated>2020-05-06T12:13:06.505Z</updated>
  <id>https://qpowe.github.io/</id>
  
  <author>
    <name>Qpowe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>判断回文</title>
    <link href="https://qpowe.github.io/post/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87.html"/>
    <id>https://qpowe.github.io/post/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87.html</id>
    <published>2020-05-06T12:12:29.000Z</published>
    <updated>2020-05-06T12:13:06.505Z</updated>
    
    <content type="html"><![CDATA[<p>判断回文的四种方法：<br>1.使用数组，前后对应元素进行比较。<br>2.使用两个栈，一个栈正序存字符串，另一个栈逆序存，分别比较栈顶元素<br>3.使用一个栈存字符串的前半部分，读取后半部分元素并将其和栈顶元素比较<br>4.使用栈和队列，用栈存字符串的前半部分，用队列存字符串的后半部分，栈顶元素和队列中元素相比较</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;判断回文的四种方法：&lt;br&gt;1.使用数组，前后对应元素进行比较。&lt;br&gt;2.使用两个栈，一个栈正序存字符串，另一个栈逆序存，分别比较栈顶元素&lt;br&gt;3.使用一个栈存字符串的前半部分，读取后半部分元素并将其和栈顶元素比较&lt;br&gt;4.使用栈和队列，用栈存字符串的前半部分，用队列
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://Qpowe.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>表达式求值算法二</title>
    <link href="https://qpowe.github.io/post/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95%E4%BA%8C.html"/>
    <id>https://qpowe.github.io/post/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95%E4%BA%8C.html</id>
    <published>2020-05-06T12:01:49.000Z</published>
    <updated>2020-05-06T12:13:06.505Z</updated>
    
    <content type="html"><![CDATA[<p>1.中缀表达式转为后缀表达式（把转换后的后缀表达式存入字符数组中）：<br>（1）初始化栈。<br>（2）从左至右依次读取表达式中的字符并进行如下操作，直至整个表达式读完。<br>    ①若读入字符为运算数则将其存入字符数组，继续读入下一个字符，若是，将读入字符存入数组中，否则存入“ ”。<br>    ②若读入字符为运算符且栈空，则将读入字符如栈。<br>    ③若读入字符为“+”或“-”，当栈顶元素为“（”时，则将读入字符入栈；否则，将栈顶元素弹出并将弹出元素存入数组中，并将读入<br>        字符入栈。<br>    ④若读入字符为“<em>”或“/”，当栈顶元素为“</em>”或“/”时，则将栈顶元素弹出并将    弹出元素存入数组中，并将读入字符入栈;否则,将读入字符<br>        入栈。<br>    ⑤若读入字符为“（”，则将读入字符入栈。<br>    ⑥若读入字符为“）”，则将弹出栈顶元素，并将弹出的运算符存入数组中，直到栈顶元素为“（”，此时弹出栈顶元素。<br>    ⑦若读入字符为“#”，则break。<br>（3）表达式字符读入完成后，如果栈中不空，则将栈中字符全部弹出，存入数组中。<br>2.后缀表达式求值：<br>（1）从左至右读取数组中的元素，并进行如下操作：<br>    ①若读入字符为运算数，则将其入栈。<br>    ②若读入字符为运算符，则分两次弹出栈顶元素作为运算数进行运算，并将运算结果入栈。<br>（2）读取并返回栈顶元素即为表达式的运算结果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.中缀表达式转为后缀表达式（把转换后的后缀表达式存入字符数组中）：&lt;br&gt;（1）初始化栈。&lt;br&gt;（2）从左至右依次读取表达式中的字符并进行如下操作，直至整个表达式读完。&lt;br&gt;    ①若读入字符为运算数则将其存入字符数组，继续读入下一个字符，若是，将读入字符存入数组中
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://Qpowe.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>表达式求值算法一</title>
    <link href="https://qpowe.github.io/post/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95%E4%B8%80.html"/>
    <id>https://qpowe.github.io/post/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95%E4%B8%80.html</id>
    <published>2020-05-06T11:59:38.000Z</published>
    <updated>2020-05-06T12:13:06.505Z</updated>
    
    <content type="html"><![CDATA[<p>1.置操作数栈为空栈，表达式起始符“#”为栈底元素。<br>2.依次读入表达式中的每个字符并进行如下判断，直至整个表达式读完且表达式求值运算完毕(即OPTR栈的栈顶元素和当前输入的字符均为“#”)。<br>（1）若读入字符是操作数，则将输入字符存入数组中，继续判断下一字符是否为操作数，若是，则继续存入数组中，若不是则将数组中的字符读出入OPND栈。<br>（2）若读入字符是运算符，则根据已存入二维数组中的两两运算符间优先级关系，将读入字符和OPTR栈的栈顶运算符比较优先权后作相应操作：<br>    ①若栈顶元素优先级低于读入字符的优先级，则将读入字符入OPTR栈，并读取下一个字符。<br>    ②若栈顶元素优先级等于读入字符的优先级，说明括号相遇，也就是读入字符    为“）”，栈顶元素为“（”，删除栈内括号“（”即可，则弹出<br>        OPTR栈顶的元素，并读取下一个字符。<br>    ③若栈顶元素优先级高于读入字符的优先级，需要先进行栈顶运算符运算，则弹出OPTR栈的栈顶元素作为运算符，分两次弹出OPND栈的栈顶元<br>        素作为操作数进行运算，并将运算结果压入栈中。<br>3.读取并返回OPND栈的栈顶元素即为表达式的运算结果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.置操作数栈为空栈，表达式起始符“#”为栈底元素。&lt;br&gt;2.依次读入表达式中的每个字符并进行如下判断，直至整个表达式读完且表达式求值运算完毕(即OPTR栈的栈顶元素和当前输入的字符均为“#”)。&lt;br&gt;（1）若读入字符是操作数，则将输入字符存入数组中，继续判断下一字符是
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://Qpowe.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>借助队列对栈中元素排序</title>
    <link href="https://qpowe.github.io/post/%E5%80%9F%E5%8A%A9%E9%98%9F%E5%88%97%E5%AF%B9%E6%A0%88%E4%B8%AD%E5%85%83%E7%B4%A0%E6%8E%92%E5%BA%8F.html"/>
    <id>https://qpowe.github.io/post/%E5%80%9F%E5%8A%A9%E9%98%9F%E5%88%97%E5%AF%B9%E6%A0%88%E4%B8%AD%E5%85%83%E7%B4%A0%E6%8E%92%E5%BA%8F.html</id>
    <published>2020-05-06T11:54:24.000Z</published>
    <updated>2020-05-06T12:13:06.505Z</updated>
    
    <content type="html"><![CDATA[<p>问题描述：<br>栈中元素无序，借助队列将栈中元素排序<br>解题思路：<br>1.初始化三个队列，分别为q1、q2、q3<br>2.读取栈顶元素，并作如下操作，直到栈空，最后结果保存在q3中。<br>（1）如果q1队尾元素小于等于栈顶元素，则弹出栈顶元素并将其存入q1队列中，并读取栈顶元素。<br>（2）如果q1队尾元素大于栈顶元素，则比较q2队尾元素和栈顶元素，若q2队尾元素小于等于栈顶元素，则弹出栈顶元素，并将栈顶元素存入q2队列中，并读取栈顶元素。<br>（3）如果q2队尾元素大于栈顶元素，则对各自有序的队列1和队列2中的元素进行排序，结果存入队列q3中，此时，q1、q2空，然后q1和q3进行交换，并读取栈顶元素。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;问题描述：&lt;br&gt;栈中元素无序，借助队列将栈中元素排序&lt;br&gt;解题思路：&lt;br&gt;1.初始化三个队列，分别为q1、q2、q3&lt;br&gt;2.读取栈顶元素，并作如下操作，直到栈空，最后结果保存在q3中。&lt;br&gt;（1）如果q1队尾元素小于等于栈顶元素，则弹出栈顶元素并将其存入q1队列
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://Qpowe.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>第一次使用</title>
    <link href="https://qpowe.github.io/post/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8.html"/>
    <id>https://qpowe.github.io/post/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8.html</id>
    <published>2020-05-05T11:22:35.000Z</published>
    <updated>2020-05-06T12:13:06.505Z</updated>
    
    <content type="html"><![CDATA[<p>第一次使用，记录一下，哈哈哈，以后要多记录</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第一次使用，记录一下，哈哈哈，以后要多记录&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
</feed>
